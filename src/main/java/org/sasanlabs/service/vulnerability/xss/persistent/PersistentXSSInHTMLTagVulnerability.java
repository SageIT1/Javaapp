package org.sasanlabs.service.vulnerability.xss.persistent;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.Pattern;
import org.apache.commons.text.StringEscapeUtils;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.sasanlabs.vulnerability.utils.Constants;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.RequestParam;

@VulnerableAppRestController(
        descriptionLabel = "XSS_VULNERABILITY",
        value = "PersistentXSSInHTMLTagVulnerability")
public class PersistentXSSInHTMLTagVulnerability {
    private static final String PARAMETER_NAME = "comment";
    private static final Pattern IMG_INPUT_TAG_PATTERN = Pattern.compile("(<img)|(<input)+");
    private static final Pattern IMG_INPUT_SCRIPT_CI_PATTERN =
            Pattern.compile("((?i)<img)|((?i)<script)+");
    private final PostRepository postRepository;
    public PersistentXSSInHTMLTagVulnerability(PostRepository postRepository) {
        this.postRepository = postRepository;
    }
    private String getCommentsPayload(
            Map<String, String> queryParams, String level, Function<String, String> fn) {
        if (queryParams.containsKey(PARAMETER_NAME)) {
            Post post = new Post();
            post.setLevelIdentifier(level);
            post.setContent(queryParams.get(PARAMETER_NAME)); // stores untrusted input
            postRepository.save(post);
        }
        StringBuilder out = new StringBuilder();
        postRepository.findByLevelIdentifier(level)
                .forEach(p -> out.append("<div id=\"comments\">")
                        .append(fn.apply(p.getContent()))
                        .append("</div>"));
        return out.toString();
    }
    @AttackVector(vulnerabilityExposed = VulnerabilityType.PERSISTENT_XSS)
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> level1(@RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<>(getCommentsPayload(queryParams, LevelConstants.LEVEL_1, p -> p),
                HttpStatus.OK);
    }
    @AttackVector(vulnerabilityExposed = VulnerabilityType.PERSISTENT_XSS)
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> level2(@RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<>(
                getCommentsPayload(queryParams, LevelConstants.LEVEL_2,
                        p -> IMG_INPUT_TAG_PATTERN.matcher(p).replaceAll("")),
                HttpStatus.OK);
    }
    @AttackVector(vulnerabilityExposed = VulnerabilityType.PERSISTENT_XSS)
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_3, htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> level3(@RequestParam Map<String, String> queryParams) {

        Function<String, String> fn = post -> {
            if (post.contains(Constants.NULL_BYTE_CHARACTER)) {
                int idx = post.indexOf(Constants.NULL_BYTE_CHARACTER);
                // vulnerable: tail after null byte stays unescaped
                return StringEscapeUtils.escapeHtml4(post.substring(0, idx))
                        + post.substring(idx);
            }
            return IMG_INPUT_SCRIPT_CI_PATTERN.matcher(post).replaceAll("");
        };
        return new ResponseEntity<>(
                getCommentsPayload(queryParams, LevelConstants.LEVEL_3, fn),
                HttpStatus.OK);
    }
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/PersistentXSS",
            variant = Variant.SECURE)
    public ResponseEntity<String> level4(@RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<>(
                getCommentsPayload(queryParams, LevelConstants.LEVEL_4,
                        StringEscapeUtils::escapeHtml4),
                HttpStatus.OK);
    }
}
